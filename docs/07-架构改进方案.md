# 简家厨 - 架构改进方案

> 日期: 2026-02-19
> 核心理念: "一菜两吃" — 大人与宝宝同步出餐策略

---

## 一、当前架构评估

### 做得好的部分
- React Query 管理远程数据状态，缓存策略合理
- 三级搜索瀑布（本地→天行→AI）设计清晰
- 规则引擎式的食谱转换（年龄→食材/步骤/调料适配）逻辑完整
- 4 套主题切换 + 响应式设计
- 完整的购物清单→食材库存链路

### 核心缺陷

| 问题 | 严重度 | 说明 |
|------|--------|------|
| "一菜两吃"体验断裂 | **高** | 大人版和宝宝版在 UI 上只是 Tab 切换，没有呈现**同步烹饪时间线**（哪一步可以共用、何时分叉、分别操作多久） |
| 宝宝版数据二义性 | **高** | 同一道菜既有静态 seed 的 `baby_version`，又有动态转换的 `TransformResult.baby_version`，前端取数逻辑混乱 |
| 认证流程失效 | **中** | `App.tsx` 直接渲染 `MainNavigator`，`RootNavigator` 从未使用，登录/注册页面不可达 |
| 周计划未考虑宝宝 | **中** | `meal_plans` 表只存一个 `recipe_id`，没有区分大人/宝宝版，也没有按宝宝月龄过滤不适宜食谱 |
| 转换缓存仅内存 | **低** | `transformCache` 是进程级 Map，重启即丢失 |
| 日志泄露 | **低** | 前后端大量 `console.log` 遗留在生产路径中 |

---

## 二、改进方案（按优先级排列）

---

### 方案 1: 同步烹饪时间线（Sync Cooking Timeline）

**问题**: 项目核心卖点是"一菜两吃"，但目前只是两个独立的食材+步骤列表的 Tab 切换。家长在厨房里真正需要的是: **一个统一的、按时间排列的操作序列**，告诉他/她"现在做什么、给谁做、下一步做什么"。

**设计思路**:

```
时间线视图 (Timeline View)
─────────────────────────────
[共用] 1. 洗净番茄、鸡蛋         ⏱ 3分钟
[共用] 2. 番茄切块、鸡蛋打散       ⏱ 5分钟
──── 分叉点 ────
[宝宝🍼] 3a. 取1/4食材，水煮至软烂   ⏱ 8分钟
[大人🍽️] 3b. 热油，放入蒜末爆香     ⏱ 2分钟
[大人🍽️] 4b. 炒蛋、炒番茄、调味     ⏱ 5分钟
[宝宝🍼] 4a. 捞出压成泥/小块       ⏱ 2分钟
──── 完成 ────
总用时: 约 18分钟 (节省 vs 分开做: ~12分钟)
```

**数据模型扩展**:

```
SyncTimeline {
  recipe_id: string
  baby_age_months: number
  total_time: number          // 总用时（分钟）
  time_saved: number          // 比分开做省多少分钟
  phases: TimelinePhase[]
}

TimelinePhase {
  order: number
  type: 'shared' | 'adult_only' | 'baby_only' | 'fork_point'
  target: 'both' | 'adult' | 'baby'
  action: string
  duration: number            // 分钟
  tools?: string[]
  note?: string               // 如 "宝宝份不加盐"
  parallel_with?: number      // 可以与哪个 phase 并行
}
```

**关键决策**:
- 时间线应由后端**生成**还是前端**计算**？
  - 建议: **后端生成**。转换服务已有大人+宝宝的步骤数据和时间信息，在此基础上编排时间线比前端重新解析更可靠。新增 `SyncTimelineService` 即可。
- 时间线作为新的独立视图（第三个 Tab "同步烹饪"），还是替换现有的步骤列表？
  - 建议: **新增第三个 Tab**（大人版 / 宝宝版 / 同步烹饪），保留原有分开查看的能力，同时提供合并视图。

**影响范围**:
- 后端: 新增 `SyncTimelineService`，扩展 `TransformResult`
- 前端: `RecipeDetailScreen` 新增"同步烹饪"Tab，新增 `TimelineView` 组件
- 数据库: 无需改表（时间线是动态计算的）

---

### 方案 2: 统一宝宝版数据源（消除二义性）

**问题**: 当前一道菜可能同时存在:
1. 数据库 seed 的静态 `baby_version`（JSON 字段）
2. `RecipeTransformService` 动态生成的 `TransformResult.baby_version`
3. AI 搜索结果里的 `SearchResult.baby_version`（目前为空）

前端 `RecipeDetailScreen` 里用 `effectiveBaby = activeTab === 'baby' && transformedBaby ? transformedBaby : parsedBaby` 来做优先级判断，但这个逻辑散落在渲染函数里，不够清晰。

**设计思路**:

建立明确的数据优先级链:

```
BabyVersionResolver {
  resolve(recipeId, babyAgeMonths) → BabyVersion {
    1. 检查转换缓存（内存 or SQLite）
    2. 如果有静态 baby_version 且匹配月龄范围 → 使用
    3. 否则 → 调用 TransformService 动态生成
    4. 缓存结果
  }
}
```

**关键改动**:
- 后端: 将 `BabyVersionResolver` 统一为一个服务，所有获取宝宝版的入口（详情页、搜索结果、计划页）都走同一个 resolver
- 数据库: 静态 `baby_version` 增加 `age_range` 标记（表示该静态版本适合哪个月龄范围），超出范围时走动态转换
- 前端: `useRecipeDetail` hook 直接返回已解析的 `babyVersion`，屏幕组件不再自行判断数据来源

---

### 方案 3: 智能周计划（Baby-Aware Meal Planning）

**问题**: 当前 `meal_plans` 只存 `recipe_id`，没有考虑:
- 宝宝月龄对应的食材禁忌（如 < 12 月不宜蜂蜜、整颗坚果）
- 一周内营养均衡（蛋白质、铁、钙等关键营养素分布）
- 食材复用优化（周一买的番茄周三还能用）

**设计思路**:

```
SmartMealPlanService {
  generateWeeklyPlan(userId, options) {
    constraints:
      - babyAgeMonths: number        // 自动过滤不适宜食谱
      - nutritionBalance: boolean    // 保证 7 天营养均衡
      - ingredientReuse: boolean     // 优先选择可复用食材的菜谱组合
      - maxPrepTime?: number         // 每餐最大用时
      - excludeIngredients?: string[] // 过敏食材排除

    algorithm:
      1. 从菜谱库筛选月龄适宜的菜谱池
      2. 用贪心算法 + 营养约束选择 7 天 * 3 餐的菜谱
      3. 优化食材采购重叠率
      4. 输出: 周计划 + 一键生成购物清单
  }
}
```

**数据模型扩展**:

```
meal_plans 表新增:
  - baby_age_months: integer     // 生成时的宝宝月龄
  - is_baby_suitable: boolean    // 此餐是否适合宝宝
  - nutrition_score: json        // 当日累计营养打分
```

---

### 方案 4: 食材生命周期闭环

**问题**: 目前"食材库存"和"购物清单"是两个独立模块，没有形成闭环:
- 购物清单买完后不会自动入库
- 做菜后不会自动扣减库存
- 库存快过期时不会推荐相关菜谱

**设计思路**:

```
食材生命周期:

[购物清单] ──购买完成──→ [食材库存] ──做菜消耗──→ [扣减]
     ↑                        │
     │                    [临期提醒]
     │                        │
     └──推荐能用上临期食材的菜谱──┘
```

**关键能力**:
1. **购物→入库**: 购物清单标记完成时，自动将食材添加到库存（带默认保质期）
2. **做菜→扣减**: 从周计划标记"已做"时，按菜谱用量自动扣减库存
3. **临期→推荐**: 库存中 3 天内到期的食材，自动推荐含该食材的菜谱（优先推荐到今日/明日计划）
4. **库存→购物**: 根据周计划所需 vs 当前库存差值，智能生成购物清单（只买缺的）

---

### 方案 5: 认证与用户体系修复

**问题**: 认证流程完全失效，且用户数据（`baby_age`, `family_size`）没有在核心功能中被利用。

**设计思路**:

```
修复优先级:
1. App.tsx 使用 RootNavigator 替代 MainNavigator
2. 实现 RegisterScreen 的真实注册逻辑
3. 游客模式保留但限制功能（不能保存收藏/计划/库存）
4. 用户 baby_age 自动同步到所有需要月龄的功能:
   - 菜谱详情默认展示该月龄的宝宝版
   - 周计划自动按月龄过滤
   - 搜索结果标记适宜/不适宜
```

**用户 Profile 扩展**:

```
users 表新增:
  - babies: json               // 支持多个宝宝 [{name, birth_date, allergies}]
  - dietary_restrictions: json  // 家庭饮食限制（如素食、清真）
  - cooking_skill_level: enum   // 新手/普通/擅长 → 影响推荐难度
```

支持多宝宝的原因: 很多家庭有两个孩子，月龄不同，食材适配策略不同。

---

### 方案 6: 离线优先架构

**问题**: 厨房场景下网络不稳定（油烟、湿手），但当前所有数据都依赖在线 API。

**设计思路**:

```
离线策略:
1. 核心菜谱库: 首次启动时同步到本地 SQLite (react-native-quick-sqlite)
2. 已转换的宝宝版: 缓存到本地，按 (recipe_id, baby_age) 索引
3. 当前周计划 + 购物清单: 离线可读可写，上线后同步
4. 搜索: 本地搜索始终可用，联网/AI 搜索需网络
5. 烹饪计时器: 纯本地功能，已支持
```

**技术选型**:
- `@op-engineering/op-sqlite` (Expo 兼容) 或 `expo-sqlite`
- React Query 的 `persistQueryClient` + `createAsyncStoragePersister` 做查询缓存持久化

---

### 方案 7: 搜索结果与本地菜谱库打通

**问题**: AI/联网搜索到的好菜谱，用完就丢了。无法收藏、无法加入周计划、无法生成购物清单。

**设计思路**:

```
SearchResult → Recipe 转化链路:

[搜索结果] ──"收藏到我的菜谱"──→ [user_recipes 表]
                                      │
                                  自动补全缺失字段
                                  (type, category, servings)
                                      │
                                  可被周计划/购物清单引用
                                  可以做宝宝版转换
```

**数据模型**:

```
user_recipes (新表):
  id: string
  user_id: string (FK)
  source: 'tianxing' | 'ai' | 'manual'
  original_data: json          // 原始搜索结果快照
  name: string
  adult_version: json          // 标准化后的 RecipeVersion
  baby_version: json           // 转换后的缓存
  created_at: timestamp
```

---

## 三、改进优先级路线图

```
Phase 1 - 核心体验 (1-2周) ✅ 已完成 (2026-02-20)
├── [方案2] 统一宝宝版数据源 — 消除数据二义性 ✅
├── [方案5] 修复认证流程 — App.tsx + RegisterScreen ✅
└── 清理 console.log / TODO ✅

Phase 2 - 核心差异化 (2-3周) ✅ 已完成 (2026-02-20)
├── [方案1] 同步烹饪时间线 — 项目最大卖点 ✅
│   ├── 后端: SyncTimelineService + POST /recipes/:id/timeline
│   ├── 前端: TimelineView 组件（颜色编码：共用=青、分叉=黄、大人=橙、宝宝=粉）
│   └── 前端: RecipeDetailScreen 新增"同步烹饪"第三个 Tab
└── [方案7] 搜索结果保存到本地菜谱库 ✅
    ├── 后端: user_recipes 表 + UserRecipeService + CRUD 路由
    ├── 前端: SearchScreen 添加"收藏到我的菜谱"按钮
    ├── 前端: MyRecipesScreen（列表+详情+删除）
    └── 前端: ProfileScreen 新增"我的菜谱"入口

Phase 3 - 智能化 (2-3周) ✅ 已完成 (2026-02-20)
├── [方案3] 智能周计划 (月龄适配 + 营养均衡 + 食材复用) ✅
│   ├── 后端: meal_plans 表新增 baby_age_months / is_baby_suitable / nutrition_score / is_completed
│   ├── 后端: generateWeeklyPlan 增强（月龄过滤 + 营养均衡评分 + 食材复用排序）
│   └── 前端: WeeklyPlanScreen 生成选项弹窗（宝宝月龄选择 + 排除食材），餐食卡片显示👶标记
└── [方案4] 食材生命周期闭环 ✅
    ├── 后端: 购物清单 markComplete → 自动入库 ingredient_inventory（默认保质期）
    ├── 后端: 周计划 markMealCompleted → FIFO 扣减库存 + POST /meal-plans/:id/complete
    ├── 后端: suggestByInventory → 临期食材匹配菜谱 + GET /recipes/suggest-by-inventory
    ├── 前端: WeeklyPlanScreen 餐食卡片添加"已做"按钮（带确认弹窗）
    └── 前端: InventoryScreen 顶部"临期食材推荐菜谱"横向滚动区

Phase 4 - 体验打磨 (1-2周) ✅ 已完成 (2026-02-20)
├── [方案6] 离线优先架构 ✅
│   ├── 安装 @tanstack/react-query-persist-client@4 + query-async-storage-persister@4
│   ├── App.tsx: QueryClientProvider → PersistQueryClientProvider + AsyncStorage
│   ├── NetInfo 监听 → onlineManager 感知网络状态
│   ├── 关键查询 cacheTime: useAllRecipes(24h) / useRecipeDetail(7d) / useWeeklyPlan(24h) / useIngredientInventory(24h)
│   └── OfflineIndicator 组件 + MainNavigator 集成
└── 转换缓存持久化 (内存 → SQLite) ✅
    ├── 新表 transform_cache (recipe_id, baby_age_months, result, expires_at)
    ├── RecipeTransformService: getCache/setCache/clearCache 改为 DB 查询
    └── index.ts: 每 24h 定时清理过期缓存
```

---

## 四、架构原则建议

1. **单一数据源**: 每种数据只有一个权威来源。宝宝版通过 `BabyVersionResolver` 统一获取，不再在前端做来源判断。

2. **领域驱动**: 按"烹饪领域"而非"技术层"组织服务。例如 `CookingSession`（一次做菜的完整流程: 选菜→看步骤→计时→完成→扣库存）应该是一个聚合，而不是散落在多个 controller 里。

3. **宝宝月龄全局化**: `baby_age_months` 应该是全局上下文（从用户 Profile 读取），而不是每个页面各自管理一个 state。建议新增 `BabyContext` 提供 `{ babyAge, setBabyAge, babyStage }`，所有依赖月龄的组件从 Context 读取。

4. **渐进式离线**: 不必一次实现完整离线。先做"菜谱详情页离线缓存"（厨房最需要的），再逐步扩展。

5. **可观测性**: 移除 `console.log`，统一使用结构化日志（后端已有 `logger`）。前端使用 React Query DevTools + Sentry/Bugsnag 做错误追踪。

---

## 五、不建议做的事

| 诱惑 | 为什么不做 |
|------|-----------|
| 引入 Redux/Zustand | React Query + Context 已足够，增加状态库只会增加复杂度 |
| 换数据库到 PostgreSQL | SQLite 完全满足当前规模，且支持离线场景 |
| 微服务拆分 | 单体应用在当前阶段（< 100 API）完全合适 |
| 自建图片存储 | 直接用 OSS/CDN（如阿里云 OSS）上传，不值得自建 |
| 国际化 | 产品定位是中国家庭，中文即可 |
